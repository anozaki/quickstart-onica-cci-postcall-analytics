/// <reference types="node" />
import { AbstractTokenizer } from 'strtok3/lib/AbstractTokenizer';
import { IContentRangeType, IHeadRequestInfo, IRangeRequestClient } from './types';
import { IReadChunkOptions } from 'strtok3/lib/types';
/**
 * RangeRequestTokenizer is tokenizer which is an adapter for range-request clients.
 * Typically HTTP clients implementing the HTTP Range Requests (https://tools.ietf.org/html/rfc7233)
 *
 * Inspired by "XHR Reader"  written by Ant√≥nio Afonso
 * https://github.com/aadsm/jsmediatags/blob/master/src/XhrFileReader.js
 */
export declare class RangeRequestTokenizer extends AbstractTokenizer {
    private rangeRequestClient;
    private minimumChunkSize;
    private _fileData;
    constructor(rangeRequestClient: IRangeRequestClient, fileInfo: IHeadRequestInfo, minimumChunkSize: number);
    /**
     * Read portion from stream
     * @param buffer - Target buffer
     * @param options - Additional read options
     * @returns Promise with number of bytes read
     */
    readBuffer(buffer: Buffer, options?: IReadChunkOptions): Promise<number>;
    /**
     * Peek (read ahead) buffer from tokenizer
     * @param buffer - Target buffer to fill with data peek from the tokenizer-stream
     * @param options - Additional read options
     * @returns Promise with number of bytes read
     */
    peekBuffer(buffer: Buffer, options?: IReadChunkOptions): Promise<number>;
    /**
     * Ignore number of bytes, advances the pointer in under tokenizer-stream.
     * @param length - Number of bytes to skip (ignore)
     * @return actual number of bytes ignored
     */
    ignore(length: number): Promise<number>;
    private loadRange;
}
export declare function roundRange(range: [number, number], minimumChunkSize: number): [number, number];
/**
 * Convert HTTP range header value to IContentRangeType
 * @param contentRange - content range
 */
export declare function parseContentRange(contentRange: string): IContentRangeType;
