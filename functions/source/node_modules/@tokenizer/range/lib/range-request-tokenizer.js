"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseContentRange = exports.roundRange = exports.RangeRequestTokenizer = void 0;
const initDebug = require("debug");
const AbstractTokenizer_1 = require("strtok3/lib/AbstractTokenizer");
const chunked_file_data_1 = require("./chunked-file-data");
const debug = initDebug('range-request-reader');
/**
 * RangeRequestTokenizer is tokenizer which is an adapter for range-request clients.
 * Typically HTTP clients implementing the HTTP Range Requests (https://tools.ietf.org/html/rfc7233)
 *
 * Inspired by "XHR Reader"  written by AntÃ³nio Afonso
 * https://github.com/aadsm/jsmediatags/blob/master/src/XhrFileReader.js
 */
class RangeRequestTokenizer extends AbstractTokenizer_1.AbstractTokenizer {
    constructor(rangeRequestClient, fileInfo, minimumChunkSize) {
        super(fileInfo);
        this.rangeRequestClient = rangeRequestClient;
        this.minimumChunkSize = minimumChunkSize;
        if (isNaN(minimumChunkSize)) {
            throw new Error('minimumChunkSize must be a number');
        }
        this._fileData = new chunked_file_data_1.ChunkedFileData();
    }
    /**
     * Read portion from stream
     * @param buffer - Target buffer
     * @param options - Additional read options
     * @returns Promise with number of bytes read
     */
    async readBuffer(buffer, options) {
        if (options && options.position) {
            this.position = options.position;
        }
        const length = await this.peekBuffer(buffer, options);
        this.position += length;
        return length;
    }
    /**
     * Peek (read ahead) buffer from tokenizer
     * @param buffer - Target buffer to fill with data peek from the tokenizer-stream
     * @param options - Additional read options
     * @returns Promise with number of bytes read
     */
    async peekBuffer(buffer, options) {
        let length = buffer.length;
        let offset = 0;
        let position = this.position;
        if (options) {
            if (options.position) {
                position = options.position;
            }
            if (Number.isInteger(options.offset)) {
                offset = options.offset;
            }
            if (options.length) {
                length = options.length;
            }
            else {
                length -= offset;
            }
        }
        if (length === 0) {
            return 0;
        }
        debug(`peekBuffer position=${position} length=${length}`);
        const lastPos = Math.min(this.fileInfo.size - 1, position + length - 1);
        return this.loadRange([position, lastPos]).then(() => {
            this._fileData.readToBuffer(buffer, offset, position, Math.min(this.fileInfo.size, length));
            return length;
        });
    }
    /**
     * Ignore number of bytes, advances the pointer in under tokenizer-stream.
     * @param length - Number of bytes to skip (ignore)
     * @return actual number of bytes ignored
     */
    async ignore(length) {
        const bytesLeft = this.fileInfo.size - this.position;
        if (length <= bytesLeft) {
            this.position += length;
            return length;
        }
        this.position += bytesLeft;
        return bytesLeft;
    }
    async loadRange(range) {
        if (range[0] > this.fileInfo.size - 1) {
            throw new Error('End-Of-File');
        }
        debug(`request range ${range[0]}..${range[1]}`);
        debug(`adjusted range ${range[0]}..${range[1]}`);
        if (this._fileData.hasDataRange(range[0], range[1])) {
            debug(`Read from cache`);
            return Promise.resolve();
        }
        // Always download in multiples of CHUNK_SIZE. If we're going to make a
        // request might as well get a chunk that makes sense. The big cost is
        // establishing the connection so getting 10bytes or 1K doesn't really
        // make a difference.
        range = roundRange(range, this.minimumChunkSize);
        // Upper range should not be greater than max file size
        range[1] = Math.min(this.fileInfo.size - 1, range[1]);
        debug(`blocked range: ${range[0]}..${range[1]}`);
        return this.rangeRequestClient.getResponse('GET', range).then(response => {
            return response.arrayBuffer().then(data => {
                this._fileData.addData(range[0], data);
            });
        });
    }
}
exports.RangeRequestTokenizer = RangeRequestTokenizer;
function roundRange(range, minimumChunkSize) {
    const length = range[1] - range[0] + 1;
    // const newLength = Math.ceil(length / minimum_chunk_size) * minimum_chunk_size;
    const newLength = Math.max(minimumChunkSize, length);
    return [range[0], range[0] + newLength - 1];
}
exports.roundRange = roundRange;
/**
 * Convert HTTP range header value to IContentRangeType
 * @param contentRange - content range
 */
function parseContentRange(contentRange) {
    debug(`_parseContentRang response: contentRange=${contentRange}`);
    if (contentRange) {
        const parsedContentRange = contentRange.match(/bytes (\d+)-(\d+)\/(?:(\d+)|\*)/i);
        if (!parsedContentRange) {
            throw new Error('FIXME: Unknown Content-Range syntax: ' + contentRange);
        }
        return {
            firstBytePosition: parseInt(parsedContentRange[1], 10),
            lastBytePosition: parseInt(parsedContentRange[2], 10),
            instanceLength: parsedContentRange[3] ? parseInt(parsedContentRange[3], 10) : null
        };
    }
}
exports.parseContentRange = parseContentRange;
//# sourceMappingURL=range-request-tokenizer.js.map